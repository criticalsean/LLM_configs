#!/usr/bin/env python3
import argparse, json, os, re, pathlib, stat, urllib.request

# -------------------- Config: LOCKED ROOT --------------------
ROOT_ALLOW = pathlib.Path("/Users/seanbenson/SaltStackAltDoor").resolve()
READ_ONLY = True
MAX_BYTES = 2_000_000       # cap per CAT
LS_MAX = 1000               # cap per LS/LSR
FOLLOW_SYMLINKS = False     # block symlinks that could escape
OLLAMA_HOST = os.environ.get("OLLAMA_HOST", "http://127.0.0.1:11434")
API_CHAT = f"{OLLAMA_HOST}/api/chat"
# -------------------------------------------------------------

RE_LS   = re.compile(r'^\s*\[\[LS:(?P<path>/.+?)\]\]\s*$')
RE_LSR  = re.compile(r'^\s*\[\[LSR:(?P<path>/.+?):(?P<depth>\d+)\]\]\s*$')
RE_CAT  = re.compile(r'^\s*\[\[CAT:(?P<path>/.+?)(?::(?P<start>\d+)-(?P<end>\d+))?\]\]\s*$')
RE_STAT = re.compile(r'^\s*\[\[STAT:(?P<path>/.+?)\]\]\s*$')

SYSTEM_PROMPT = f"""You are connected to a filesystem bridge.

Root:
- You can ONLY access files under: {ROOT_ALLOW}

Capabilities:
- List: [[LS:/abs/path/within/root]] or [[LSR:/abs/path/within/root:depth]]
- Read ranges: [[CAT:/abs/path:start-end]] (byte offsets, inclusive-exclusive)
- Read whole file: [[CAT:/abs/path]]
- Stat: [[STAT:/abs/path]]

Contract:
- Do NOT claim to read a file unless its content appears from a bridge reply in this chat.
- When you need file info, output exactly one bracketed command on a single line and WAIT.
- If the bridge replies "NOT FOUND" or "PERMISSION DENIED", adjust and try again (max 2).
- If you can answer without FS access, say so and answer directly.
Diagnostics: BRIDGE_READY=1

Output rules:
- When acting: output only the bracketed command on a single line.
- When answering: cite the path (and byte range if used).
- Keep chain-of-thought private; provide only final answers or brief justifications.
"""

FEWSHOTS = [
    {"role":"user","content":"List the repo root."},
    {"role":"assistant","content":f"[[LS:{ROOT_ALLOW}]]"},
    {"role":"assistant","content":"(example) I see files under the allowed root. Which one to open?"},
]

def call_ollama(model, messages, stream=False, options=None):
    payload = {"model": model, "messages": messages, "stream": stream}
    if options: payload["options"] = options
    req = urllib.request.Request(API_CHAT, data=json.dumps(payload).encode(),
                                 headers={"Content-Type":"application/json"})
    with urllib.request.urlopen(req) as resp:
        return json.loads(resp.read().decode())

def ensure_in_root(user_path: str) -> pathlib.Path:
    """
    Normalize and ensure the path stays inside ROOT_ALLOW.
    User may pass either absolute or root-relative paths. We accept:
      - /Users/seanbenson/SaltStackAltDoor/...
      - /... where '...' is inside the root
    Anything else is denied.
    """
    p = pathlib.Path(user_path)
    # If it's absolute and not under root, deny early.
    if p.is_absolute():
        real = pathlib.Path(user_path).resolve(strict=False)
    else:
        real = (ROOT_ALLOW / p).resolve(strict=False)

    # Block symlinks at the final target unless explicitly allowed
    try:
        if real.is_symlink() and not FOLLOW_SYMLINKS:
            raise PermissionError(f"PERMISSION DENIED (symlink): {user_path}")
    except Exception:
        # is_symlink can raise if not existing; ignore here
        pass

    # Must stay inside ROOT_ALLOW
    root_str = str(ROOT_ALLOW) + os.sep
    real_str = str(real)
    if real_str != str(ROOT_ALLOW) and not real_str.startswith(root_str):
        raise PermissionError(f"PERMISSION DENIED: outside allowed root: {user_path}")
    return real

def do_ls(path: str):
    try:
        rp = ensure_in_root(path)
        if not rp.exists():
            return f"NOT FOUND: {path}"
        if rp.is_file():
            return json.dumps([str(rp)], indent=2)
        items = []
        for i, entry in enumerate(sorted(rp.iterdir(), key=lambda e: e.name)):
            if i >= LS_MAX: break
            t = "dir" if entry.is_dir() else "file"
            items.append({"name": entry.name, "type": t})
        return json.dumps(items, indent=2)
    except PermissionError as e:
        return str(e)
    except Exception as e:
        return f"ERROR: {type(e).__name__}: {e}"

def do_lsr(path: str, depth: int):
    try:
        rp = ensure_in_root(path)
        if not rp.exists():
            return f"NOT FOUND: {path}"
        out, count = [], 0
        def walk(p: pathlib.Path, d: int):
            nonlocal count
            if count >= LS_MAX: return
            try:
                for entry in sorted(p.iterdir(), key=lambda e: e.name):
                    if count >= LS_MAX: return
                    rel = str(entry.relative_to(rp)) if p != rp else entry.name
                    t = "dir" if entry.is_dir() else "file"
                    out.append({"path": rel, "type": t})
                    count += 1
                    if entry.is_dir() and d > 0:
                        walk(entry, d-1)
            except PermissionError:
                out.append({"path": str(p), "type":"dir", "error":"PERMISSION DENIED"})
        if rp.is_file():
            out.append({"path": rp.name, "type":"file"})
        else:
            walk(rp, depth)
        return json.dumps(out, indent=2)
    except PermissionError as e:
        return str(e)
    except Exception as e:
        return f"ERROR: {type(e).__name__}: {e}"

def do_stat(path: str):
    try:
        rp = ensure_in_root(path)
        if not rp.exists():
            return f"NOT FOUND: {path}"
        st = rp.stat()
        info = {
            "path": str(rp),
            "type": "dir" if rp.is_dir() else "file",
            "size": st.st_size,
            "mode": stat.filemode(st.st_mode),
            "mtime": int(st.st_mtime),
            "ctime": int(st.st_ctime),
        }
        return json.dumps(info, indent=2)
    except PermissionError as e:
        return str(e)
    except Exception as e:
        return f"ERROR: {type(e).__name__}: {e}"

def do_cat(path: str, start=None, end=None):
    try:
        rp = ensure_in_root(path)
        if not rp.exists():
            return f"NOT FOUND: {path}"
        if rp.is_dir():
            return f"ERROR: Is a directory: {path}"
        if start is None and end is None:
            size = rp.stat().st_size
            if size > MAX_BYTES:
                return f"ERROR: File too large ({size} bytes > {MAX_BYTES}). Provide a byte range."
            with open(rp, "rb") as f:
                data = f.read(MAX_BYTES)
            return data.decode(errors="replace")
        s = int(start or 0)
        e = int(end or min(rp.stat().st_size, s + MAX_BYTES))
        if e - s > MAX_BYTES:
            e = s + MAX_BYTES
        with open(rp, "rb") as f:
            f.seek(s)
            data = f.read(e - s)
        return data.decode(errors="replace")
    except PermissionError as e:
        return str(e)
    except Exception as e:
        return f"ERROR: {type(e).__name__}: {e}"

def extract_directive(text: str):
    for regex, kind in ((RE_LS,"LS"), (RE_LSR,"LSR"), (RE_CAT,"CAT"), (RE_STAT,"STAT")):
        m = regex.match(text or "")
        if m:
            return kind, m
    return None, None

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--model", default="llama3.1")
    ap.add_argument("--temp", type=float, default=0.2)
    args = ap.parse_args()

    messages = [
        {"role":"system","content": SYSTEM_PROMPT},
        {"role":"assistant","content":"BRIDGE_READY=1"},
        *FEWSHOTS
    ]
    print(f"Bridge ready (root = {ROOT_ALLOW}). Ctrl+C to exit.")
    while True:
        try:
            user = input("\nYou: ")
        except (EOFError, KeyboardInterrupt):
            print("\nBye."); break
        messages.append({"role":"user","content": user})

        resp = call_ollama(args.model, messages, stream=False, options={"temperature": args.temp})
        content = resp["message"]["content"]
        print(f"\nModel:\n{content}")
        messages.append({"role":"assistant","content": content})

        kind, match = extract_directive(content)
        if not kind:
            continue

        if kind == "LS":
            out = do_ls(match.group("path"))
        elif kind == "LSR":
            out = do_lsr(match.group("path"), int(match.group("depth")))
        elif kind == "CAT":
            out = do_cat(match.group("path"), match.group("start"), match.group("end"))
        elif kind == "STAT":
            out = do_stat(match.group("path"))
        else:
            out = "ERROR: Unknown directive"

        print(f"\n[Bridge]\n{out}")
        messages.append({"role":"assistant","content": f"<<BRIDGE>>\n{out}"} )

        follow = call_ollama(args.model, messages, stream=False, options={"temperature": args.temp})
        follow_text = follow["message"]["content"]
        print(f"\nModel:\n{follow_text}")
        messages.append({"role":"assistant","content": follow_text})

if __name__ == "__main__":
    main()
